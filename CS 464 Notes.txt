CS 464 Notes
Spring 2018


lecture 1  - OS definition
===============================================================================
What is open source software?

	-> source code is shared to edit and redistrib
		-> even repackage as a new project

	-> collaborative internet-based development

	-> meritocracy, best code/ideas win out
		-> anyone welcome to make contributions

	^^ Not all are necessarily true


Formal def:
	-> goverend by Open Source Inititative (OSI) approved license


1) require - free redistribution

2) require sharing of - source code

3) allow - derived works

4) maintain - integrity of author's source code

5) no discrimination against persons or groups

6) no discrim against fields of endeavor

7) distrib of license

8) license must not be specific to a product

9) license must not restrict other software

10) license must be technology neutral


Key take away:

"free and open source"

FREE AS IN FREEDOM, NOT AS IN BEER



lecture 2 - history of OS
===============================================================================

Technically.. this was the norm at the beginning of computers as software sharing was
	encourage by IBM to get more people to use computers (and hardware sales)

~1970's - software starting to gain traction (showing the value, improve value, etc.. w/o new hardaware)

Diamond V. Diehr (1981)
	-> US supreme court forces patent office to recoginze software algos patents
	-> forced open flood gates on software patents and possible rapid growth of purely
		software companies like Microsoft

Emergence of proprietary software

	-> sw controlled and owned by 1 actor

	-> to protect ownership, code is tightly controlled
		-> only authorized ppl allowed to view and edit

	-> this control and secrecy surroundign how things are done are seen as key to
		controlling the value of SW

		(dependent on vender for updates, etc..)


AT&T looked to close off UNIX, so Richard Stallman and the Free Software Foundation came along

	-> GNU public license (GNU's Not Unix)
		-> gnu c compiler (gcc)

GNU Public License (GPL)

	-> first free, or Open Software Licenses
		-> many current ones build on this

	4 Freedoms (rights, not cost)
		1) to use
		2) to copy
		3) to modify
		4) to contribute

	-> struggled w/ acceptance for corporate space
		-> enter the Open Source Initiative 
			-> designed to make "free software" more acceptable

Open Source = dev methodology
Free Software = social movement




Book chapter 1
-------------------------------------------------------------------------

One of the most common mistakes - unrealistic expectations
	-> opening a project can add a whole new set of complexities and possibly cost more in the short term

Related mistake - skimping on presentation and packaging
	-> need to clear barriers for newcomers

Mgmt in open source isnt always very visibile, but is usually happening behind the scenes in successful projects


History:
	
	early period had little standaridztion of hardware
		-> led to architecture expertise rather than language expertise
		-> in manufacturers best interest

	no widespread internet
		-> getting data from place to place was inconvenient and cumbersome
		-> assisted by knowledge sharing expectation due to many devs working at universities

Rise of Proprietary Software and Free Software

	2 things occured gradually:
		1) hardware designs gave way to a few clear winners (tech, marketing, or both)

		2) dev of "high level" langs which coudl compile to run on diff kinds of computers
			-> not locked into manufacturer

	Software become a differentiator.  Selling or treating it as an integral part of hardware sales began to look like a goo strategy.
		-> M's had to start enforcing copyrights more strictly
		-> sharing could implement "added value" features being sold (or get into competitor hands)


Stallman noticed that the community cooperation was becoming forbidden due to proprietary software and decided to resist the trend.
	-> Started GNU Project and the Free Software Foundation (FSF)
		-> GNU Goal: dev completely free and open computer operating system and body of application software (GNU's Not Unix), which users would never be prevented from hacking or from sharing their mods.

		-> dev'd GNU General Public License (GPL)
			-> copy'd and mod'd w/o restriction
				-> both copies and derivative workds must be distrubted under same license as OG
			-> prevents EVERYONE/ANYONE from limiting distribution

	FSF struggled w/ their kernal -> in comes L.T. w/ his Linux kernel
		-> add existing GNU pgms and other free SW (X Windows System)
			-> 1st free OS

	BSD - Berkeley Software Distribution
		-> gradual reimplemenetation of the UNIX OS



"Free" Versus "Open Source"

	"free software" DNE "zero-cost software"
		-> all free software is zero-cost, but not all zero-cost is free as in "freedom"
			(freedom to modify)

	gratis = free, w/o charge
	libre = free, at liberty

1998: Open Source termed as an alternative to "free" by those who became OSI
	-> contributions are evaluated on technical grounds
		-> not motivations





lecture 3 - Anatomy of an Open Source Project
============================================================================================

Tools have 3 groups:

	1) Communication tools
		-> IRC
			LCD for Real time comm
			div'd into #channels
			non-persistent w/ limited flow control
			chat for quick answers
			etc..

		-> Mailing Lists
			simple redistribution and carchiving mechanism
			hash out designs/reqs/distro
			etiquette

			recommended to start "lurking" to figure out who is who

		-> web/wiki pages
			the projects' public face
			contains info about project, members, IRC channel, possibly design docs, code repo, bug tracker, etc..

	2) Coordination Tools
		-> bug trackers (most important)
				Depends on users to find bugs (enough eyeballs)

				Ex: Bugzilla, Trac, Redmine, Jira

				database, front-end tracking
					-> outstanding issues
					-> causes
					-> who is working on them
					-> current status and priority

		-> feature requests (2nd important)

	3) Coding tools
		-> code management systems (git, hg, SVN, CVS)



Book, chapter 3 - Techncial Infrastructure
----------------------------------------------------------------------------------------------

Good information mgmt is what prevents open source projects from collapsing under the weight of Brooks' Law
	-> Brooks' Law = adding manpower to a late software project makes it later
		-> this is due to each person no longer being able to remain aware of what everyone else it doing (as # of ppl grow)



What a Project Needs:

	Web site
	Mailing lists / Msg forums
	Version control
	Bug Tracking
	Real-time chat


	Web Site:
		devoted to helping people participate in the project (different than the public facing one)
			-> could be 1 for broad users who want to get involved
			-> 1 for developers
			-> 1 for public

				You might have less for small projects.  Need to determine what is right for you.


	Canned Hosting:
		-> online service that offers some or all of the online collab tools needed to run a free software project
			minimum: version control repo, bug tracking.  Most offer wiki, may offer mailing list hosting, some offer continuous integration testing and other services

		2 main advs:
			1) server capactiy and bandwidth
			2) simplicity
				-> they already chose and setup everything for you!

		disadv:
			you must accept their choices and configs
				-> try to arrange things so you aren't locked in if you need to switch later

		
	Mailing Lists / Message Forums
		-> larger, more complex projects will benefit from the forums
		-> these 2 terms are becoming nearly unified

		-> should have a prominently placed description of all available public forms
			-> guide newcomers


	Choosing the right forum mgmt software

		Need to consider these:
			i) both email and web-based access
			ii) moderation features
			iii) rich admin interface
			iv) header manipulation
				-> (email filtering and replying rules)
			v) archiving


	Spam Prevention:

		Filtering posts: 3 basic techniques
			1) only auto-allow postings from list subscribers
				-> don't make others auto discard, go to a mod queue
				-> email addresses aren't reliable method of identifying ppl
					-> could reply from diff email or 1st time poster

			2) Filtering posts through spam-detection software

			3) Moderation
				-> mail routed to a specific holding area, where human examines it, then confirms or rejects it


	Archiving:
		Every discussion forum should be fully archived



Version Control:  version control system (or revision control system)
	-> combo of tech and practices for trackign and controlling changes to a project's files, particularly source code, documentation, and web pages

	Helps with almost every aspect of running a project:
		inter-dev comms
		release mgmt
		bug mgmt
		code stabilty and experimental dev efforts
		attribution and auth of changes by particular devs


	core = change mgmt


	Vocab:
		commit - make chng to project (to store the change in the version ctrl database)

		push - publish a commit to a publicly online repo

		pull - (update) to get project changes from project's mainline dev branch

		commit msg or log msg - commentary attached to each commit

		repository - db whr changes are stored and from which they are published

		clone (see also checkout) - to obtain one's own dev repo by making a copy of the project's central repo

		checkout - like clone, but obtains a working copy or working files from a repo

		working copy or working files - a dev's private directory tree contaiing the prj's source code files and possibly its web pages or other docs

		revision, change, changeset, or (again) commit - precisely spec'd incarnation of the prj at a pt in time

		diff - textual rep of a change, shows which lines were changed and how, plus a few surrounding context on either side

		tag or snapshot - label for a particular state of the project at a point in time.  Generally used to mark interesting snapshots of the project

		branch - copy of the project, isolated so changes made to this don't affect other branches

		merge or port - move chng from one branch to another.. merge can result in conflicts sometimes

		conflict - what happens when 2 ppl try to make diff chngs to the same place in the code.. human needs to resolve the conflict

		revert or reversion - under an already commited chng to the software

		lock - way to declare an exclusive intent to change a particular file or directory
			-> many require the lock-mod-unlock model


	VERSION EVERYTHING!!!
		-> keeps it organized, and good for tracking all updates


	Browsability
		-> prj's repo should be browsable on the web.
		-> ability to look ato both latest and earlier revisions/logs


	Use branches to avoid bottlenecks
		-> they turn a scarce resource - working room in the prj's code - into an abundant one.
		-> when branch is successful with implementing a feature/design, others examine a pull request
			-> if pull request result is good, system can do a merge to the master branch


	Singularity of Information
		never commit the same change twice
		use consistent syntax for changes


	Authorization
		most projects use honor system for commit access


	Receiving and Reviewing Contributions

		Pull Requests - primary method
			-> from contributor to the prj that a certain change be pulled into the prj
			-> change offered int he form of the diff b/w the contrib's copy and the prj's own copy


		Comit Notifications/Emails
			-> every commit or push containing a group of commits should generate a notification that goes out to a subscribable forum, such as an email sent to a mailing list
				-> include basic info about the change


Bug Tracker:

	used for: 
		bug tracking
		new feature reqs
		1 time tasks
		unsolicited patches
		etc..

	aka: issue trackers, ticket trackers, request trackers.. etc...

	steps:

		1) someone files a ticket
		2) others read ticket, add to it
		3) bug gets reproduced
		4) bug gets diagnosed (cause and effort to fix is estimated)
		5) ticket gets scheduled for resolution (possible future release date)
		6) bug gets fixed (or task completed..etc)


IRC / Real Time Chat Systems
	-> could host with Freenode
	-> IRC needs archiving added w/ something like ZNC

	Has bots which you can configure to say different things (useful links)
		-> could have this watch the prj's VCR (version control repo) and broadcast commit activity

	-> great for social aspects and being part of something alive


Wikis
	-> never allow anonymous editing of the wiki

	Usually best to use the built in wiki feature - if the hosting site or project site has it



week 3
----------------------------------------------------------------------------------------------------------

What is a VCS video
	-> we need something to be able to track (revision history) for teams that often work on the same collection of files (even same file) at the same time
		-> merges the file back together with edits, provided they aren't at the exact same point in the file
			-> I'd have to resolve this manually

	Git = fast and modern
		-> provides history of content changes
		-> facilitates collaborative changes to files
		-> easy to use for any time of knowledge worker


		


week 4
------------------------------------------------------------------------------

Participation lecture
==============================================================================


Why do it?  Motivations:
	Individual Level:
			-> job (paid to do it)
			-> reputation (looks good on resume)
			-> career developmment, skill-gaining
			-> fun, hobby, intellectually stimulating
			-> personal needs (fixing a bug when it matters to them)
			-> desire to work with other humans and to give/earn respect/status through cooperative activities

	Indv: participation (on average)

			prj leaders: 12 hrs/wk
			bug fixers/active users: 5 hrs/wk
			most frequent answer providers: 1.5 hrs/wk

			the most common length of participation, (across all time) across all roles, no longer than a single month (w/ a highly skewed [pareto/power-law] distrubition of participation)  aka very few contributing most, very many contributing a little

	Firm lvl:
			-> create a service business around open source software
				(think red hat and fedora)
			-> as many as 45% of contributors are paid by firms for their participation
			-> sponsoring OSS and employing software engs to participate
			-> allows smaller firms to innovate b/c "many eyes" assist them in swe dev
			-> revealing code to receive outside tech support
			-> b/c of the quality and reliability of FOSS


	Common mechanisms for sharing:
		technical tasks
		management tasks

		best practices for sharing technical tasks:
			delegation
			praise and criticism
			prevent territoriality
			treat every user as a potential participant
			automation ratio
				-> as a rule of thumb, automating a common task is worth at least 10x the effort a dev would spend doing that task manually one time.

		sharing mgmt tasks
			-> as prj becomes more complex, this becomes more impt

			common roles:
				patch mgr
				translation mgr
				documentaiton mgr
				issue mgr
				ppl would commit access
				release mgr

			How to handle transitions
				-> friendly and guilt free
				-> find out info, not make anyone feel bad
				-> contact privately

	credit: always give credit to who did what and when
		-> be specific



	in person meeting venues:
		conferences
		hackfests
		hackathons
		code sprints
		retreats
		meetups - not only for writing code.. could be docs, user testing, qa sprints, etc..

		primary output of these are social connections



Section 4.2 from  “Free/Libre open-source software development: What we know and what we do not know.” By Crowston et al.  (total 4 pages)
----------------------------------------------------------------------------
4.2 Inputs

	Member characteristics of FLOSS teams:
		Geographic location:
			North America and Europe are the most active locations for users/devs
				-> esp Ger, France, UK

			Asia and Latina America are at a slight dis adv due to lang barrier

		Motivation for participation:
			Lerner and Tirole economic modeling showed that it is derived from indirect signaling about quality w/ the payoff to come in higher career earnings
				-> empirical work found little evid to support this, but not discredited

			Individual lvl motiviation:
				-> reputation and rewards (such as career development)
				-> enjoyment aka fun, sharing, learning
				-> personal needs
				-> leadership 
				-> relationships

			Firm lvl:
				-> primarily through creating a service business around OSS
				-> or sponsoring OSS and employing SW ENGS to participate

		random note: less restrictive licenses typically leads to higher output per contributor

	Project characteristics:
		-> SW License types attract the most attn here
			-> plays a crucial role w/ respect to all activities in FLOSS dev, particularly when commercial firms are involved
				types
					-> unrestrictive 	eg. BSD
					-> restrictive 		eg. LGPL
					-> highly restrictive eg. GPL
						-> often times geared more to end users rather than devs

		Technology Use:
			important input since FLOSS team members coordinate their activity primarily by means of computer mediated comms


Chapter 8 - managing participants
===================================================================================

	politics are inevitable whenever pppl have to cooperatively managed a shared resource
		-> all consequences of decisions must be taken into account

Community and Motivation
	as we've seen already... job, paycheck, personal satisfaction, human connections/interaction, educational value, respect, etc..

	Delegation
		-> consider all effects when you ask someone to do something
			-> you trust that person, but you aren't doing the work
			-> others are made aware of that trust - if done publically
			-> they may feel pressure to accept

		-> b/c of all the ffects, it often makes sense to ask someone else to do something even when you know you coudl do it yourself faster or better


Distinguish Clearly Between Inquiry and Assignment
	One thing that almost always causes people instant annoyance is being asked to do something in a way that implies that you think it is clearly their responsibility to do it, when they feel otherwise.
		-> assignment of incoming tickets is an example here
			-> if you assign to the expert w/o permission, that person may be in an uncomfortable position


Follow up after you delegate
	-> follow up no matter what
		-> if no response after a few days
		-> not to humiliate any one - is there to keep track	

Notice what people are interested in
	-> remember aspects of someone's personality
		-> they will be more comfortable

	-> don't assume something excites everyone
		-> some could like the 1.0 release, some the features/interesting probs, etc..

Praise and Criticism
	Not opposites, many ways - they are similar
		-> most effective when specific, not generic
	-> should be deployed with concrete goals in mind
		-> too much or too often will devalue

	detailed AND dispassionate must be met for critisim to be regarded as a kind of praise
		-> if not both, is bad


Prevent Territoriality
	-> watch out for ppl trying to stack exclusive ownership of certain areas of the prj
		-> creates a single pt of failure and can be destructive

		-> informal authority is granted based on competence and proven judgement, but it should never be actively taken


	Cookie Licking
		-> someone claims (publically) they will take care of something, then doesn't
			aka, no one would pick up and eat the licked cookie


	-> for these reasons, it is a typical practice to prevent sole ownership of a certain area


The Automation Ratio
	-> automating common task is worht at least 10x the effort a dev would psend doing that task manually 1 time.. this could go higher as well for freq or complex tasks


Automated Testing
	-> extremely helpful for OS projects b/c allows devs to feel comfortable changing code in areas they are unfamiliar w/
		-> encourages exploratory development
		-> regression testing is key here

	Regression testing means testing working SW that stays working
		-> to try to reduce chances that code changes will break the SW, particularly in ways that it has been broken b4
			-> many have a regression test suite

	Unit testing - reduce chance mods break existing functionality
		-> also has a suite

		
Treat every use at a potential participant
	-> each interaction w/ a user is an opportunity to get a new participant
		-> if someone did something with the project (in any way, shape, or form) they already implied they have more potential for involvement


	-> be brief, but concise and effective with your responses
		-> be curtious even if you have seen it a thousand times
		-> ask for details and direct them to proper channels


Meeting In Person (conferences, hackfets, thons, sprints, retreats)
	-> primary output of these are social connections
		-> not bug fixes or features implemented
		-> aim for increased trust and richer shared vocab b/w devs


Share MGMT tasks, not just tech tasks
	-> Manager does not mean owner
		-> think responsibility w/o monopoly
		-> domain managers should document there work in case someone leaves, then someone else can step right in


	Patch Mgr (or PR Mgr)
		-> if there are a lot of patches, someone should manage this
		-> job to make sure thinks don't slip through the cracks when people contribute

	Translation Mgr
		could be 2 diff things
			1) software docs to other languages
			2) software itself - that is, having the pgm display errors and help msgs in the user's preferred language

			-> both complex tasks, but largely separable from other development

Internationalization Versus Localization
The distinction between them is subtle but important: 

	-> Internationalization is the adaptation of products for potential use virtually everywhere, while

	-> localization is the addition of special features for use in a specific locale.

	Doc Mgr
		-> keep docs up to date is a never ending task
		-> every new feature or enhancement needs docs or changes to current docs

		-> also reviews redudent or outdated materials


	Issue Mgr
		-> helps cope with bug reports/tracking/growth (as user base grows)
			-> watching what goes into the DB and sweep through looking for specific probs




Commiters
	commiter: one of the official maintainers of the prjs code
		-> has commit access (make changes to the copy of the code that is the official release)


Credit
	-> primary currency of the free software world
	-> keep accurate records
	-> assure credit is distributed accurately




week 5
------------------------------------------------------------------------------

Communications lecture
==============================================================================


You are what you write
	-> write clearly
	-> empathize w/ audience

	-> use complete sentences
	-> coherent narrative structure
	-> informative subject line

		-> basically, make things easy for your readers


Tone
	-> be sensitive with the tone since it is hard to infer

Rudeness
	What doesn't constitue as rudeness?
		-> technical criticism
		-> blunt, unadorned questions

	What is rude?
		-> ignoring someone's work
		-> Failure to provide quality critism
			-> take time to analyze


Use a consistent screen name everywhere
	-> this is your "online face"


Avoid common pitfalls
	on a busy mailing list - 2 objectives
		-> figure out what you need to pay attention to (signal) and what can be ignored (noise)

		-> to behave in a way that avoids causing noise
			-> you want a high signal/noise ratio

			to avoid making noise, respond to these types of things
				-> point a flaw
				-> clarify miscommunication
				-> to thank someone


"Law of Triviality"
	-> the amt of dicussion is inversly proportional to the complexity of the topic


Avoid holy wars
	-> dispute which is not resolvable on the merits of argument but where people feel passionate and strong enough to continuing arguing anyway


How to handle growth
	-> people showing up for info increases dramatically
		-> # of pl to provide info increases more slowly

	-> makre sure there are many automated sources of info available


Codifying Tradition
	-> as prj acquires history and complexity, the amt of data each new participant must absorb increases

	-> the traditions a prj accumulates are as much about how to comm and preserve info as they are abt coding standards an dother technical minutiae

	-> watch for patterns in how ppl get confused

	-> as a project grows, consistency becomes more important



Chapter 6 - Communications
===================================================================================

For email:
	-> send plain text emails only
	-> consturct the subject lines of new mails carefully


Content:
	-> make things easy for your readers
		-> posts should provide info in the form most convenient for them
		-> take a few mins to summarize something when answering questions

	-> don't engage in hyperbole
		-> "this would be a nightmare"
		-> instead, use "that works, but it's less than ideal for x and y"

Keep signature blocks small and tasteful
	-> no legal jargon blocks that are obtrusive and ridiculous

Avoid common pitfalls
	-> don't post w/o a puprose
		-> you don't have to respond to everything

		Q's to ask yourself:
			-> do you know what you want to accomplish?
			-> will it not get accomplished unless you say something?


The "noisy minority" effect:
	-> it is easy for a small minority to give the impression that there is a great deal of dissent by flooding the mailing list w/ numerous lengthy emails
		-> a bit like a filibuster, except that the illusion of widespread dissent is even more powerful
			-> it is an instinctive impression rather than tracking things down (when/where)

		-> to counteract, point it out very clearly and provide supporting evidence showing how small the number of dissenters is, compared to those in agreement


Don't bash competing open source products
	-> fine to give negative facts, but don't give negative opinions
		-> could start a flame war
		-> some of the devs in your project may work for that project as well



Handling Difficult People
	-> helps to understand mentality
	-> often better to tolerate the difficulty for a while, if it is not debilitating to the prj
		-> if it gets too damaging, time for action
			-> start a private convo with other participants
				-> first ask them what they have observed (get unfiltered feedback)

			-> never accuse them of maliciously abusing the prjs procedures, being paranoid, or other things
				-> bring examples


Treat all resources like archives


Choose the right forum
	-> tricky to get people to be thoughtful about forum choice
	-> IRC great for quick questions, but not for making decisions that affect the whole prj

	-> if you move to a different form, make sure they are cross-linked to have all the information



Publicity

	-> target audience is always ill-defined, so a smooth continumm b/w internal and public relation statements

	Announcing Releases and other Major Events
		-> Put a blub on the front page
		-> Should have "news" or "press releases" area of website
			-> write up in detail
		-> broadcast to relevant social media feeds
		-> post to forums as appropriate
		-> send mail to announcment mailing list

	Announcing Security Vulnerabilities
		-> doing things openly and transparently is almost religious credo
			-> but here, merely this could be bad

		-> don't talk about the bug publicly until a fix is available
			-> supply fix at same time as announcement

		-> come up with a fix asap


	-> prj needs a secured way to receive reports
		-> separate mailing list or contact form for security bugs


	Quietly dev the fix
		-> Get all the report info
		-> should be treated urgently 

		-> could get anonoymous reports
			-> they could give you a date w/ threat to go public

		-> don't commit a fix to a public reo b4 the go-public database
			-> ppl are watching wizouski
			

Week 6
===============================================================================

Open source lectures

Can open source be traced to the 17th century?
https://www.ted.com/talks/clay_shirky_how_the_internet_will_one_day_transform_government
------------------------------------------------------------------------------


when a lot of new ideas come into society, it changes society

more media always meands more argument


Creators of "philosophical transactions"
	For arguments/experiments
		-> publish not just claims, but also how you did the expirement
		-> invented the scientific journal
		-> couldn't have been created without printing press

Open source (with source control)
	-> like feudalism where a few have control over what can be added to source control
	WE DON'T LIKE THIS

	Linus T said, "I'm not going to do that"
		-> didn't want to adopt anything that didn't work the way the linux community worked

	-> came up with git
		-> distributed version control

		lives up to 2 big promises
			-> everybody who works on it has access to all the source code, all the time
			-> unique identifier tied to every change (signature)	
				-> "cooperation w/o coordination"

Code has been put on github that you can see:
	-> which senators have sponsered which bills
	-> code for state of utah for their laws
		-> could be used to further development of their legislation


The people who have power aren't expirementing with legislation, while those that don't
have power are.
	-> Are we going to use this type of distributed system for the better of society or not?
		-> We could edit bills for the better of the people


Salvatore Iaconesi: What happened when I open-sourced my brain cancer
https://www.ted.com/talks/salvatore_iaconesi_what_happened_when_i_open_sourced_my_brain_cancer
------------------------------------------------------------------------------------------------

Forced to wait for a series of professional strangers

	-> Made website
	-> received 500k contacts
		-> many on how to cure hiself on a full individual
		-> provided support and an active roll in helping him get well
		-> went for surgery

		-> was able to talk to the doctor about things intelligently
		-> was important to participate in an engaged society


Jennifer Pahlka: Coding a better government
https://www.ted.com/talks/jennifer_pahlka_coding_a_better_government#t-49359
------------------------------------------------------------------------------------------------

apps to gamify and take ownership/name things in the community that need cared for
	-> fire hydrants
	-> tsunami sirens
	-> etc..

new generation tackling government as a collective action

citizens connect app
	-> public info
	-> people can help then comment with resolutions

neighbor is far more cheaper than gov services
	-> great for crowdsourcing

If we want bureaucracy to work for us, we need to make it sexy
	-> where real work happens

ocuppySEC
	-> 325 page report response to the SEC's request for comment on financial reform bill
		-> bc.. active





Week 7
===============================================================================

starting and open source project lecture
-----------------------------------------------
Look around to see if there is an existing project that does what you want
	-> easier than starting a brand new one


Need to acquire
	-> users
	-> developers

Decide what the project is really about and what it isn't
	-> define limitations

write a mission statement
	-> will benefit newcomers
	-> done in README.md (preferably in markdown)
	-> clear and short
		-> so newcomer can decide w/in 30 seconds if they are interested
	-> place on front page, preferably under the project's name
	-> clearly stated it is "free" or "open source"


"hacktivation energy"
	-> amt of energy a newcomer must put in b4 she starts getting something back
	-> lower, the better (to encourage involvement)

choose a name
	-> gives idea what prj does
	-> easy to remember
	-> not used elsewhere
	-> available at a domain
	-> social media username avail


features and req list
	-> list of features the sw supports
		-> even if it is a wish list


Provide comm channels
	-> how to reach other humans in prj?
		-> provide mailing list addresses, chat rooms, IRC channels
		-> make it clear who the authors are and whr they can be reached


Add dev guidelines
	-> written for someone considering contributing
		-> more social than technical

	-> pointers to forums for interaction
	-> instructions on how to report bugs and submit patches
	-> indication of how dev is usually done and how decisions are made


Add documentation
	-> quickly setup software
	-> overview of how it works
	-> tutorials
	-> FAQ
	-> Demos, screenshots, videos, etc..


Annoucing your project
	-> once prj is presentable, ann. publicially
	-> best is usually something like hacker news or sub reddits
		-> more like a planted seed than spike


Releases
	-> some old bugs fixed
	-> new bugs added
	-> new features added
	-> install procedures changed
	-> incompatible changes introduced

	Alpha
		-> 1st release, which users can get real work done w/ intended functionality
		-> known bugs
		-> main purpose to generate feedback

	Beta
		-> software's APIs are finalized and its serious known bugs fixed
		-> not yet tested enough to certify for production release
		-> purpose to either become the official release (assuming no bugs) or provide detailed feedback to the devs so they can reach the official release quickly


	Number conventions
		-> should unambiguously comm the ordering of releases
		-> groups of digits sep'd by dots
			ProjName 2.11.3
					 2.11.4 (Alpha)
					 2.11.4 (Beta)

			first = major
				-> expected to bring new features
				-> changes can be FWD BWD incompatible

			second = minor
				-> May introduce new features
				-> changes must be BWD compatible

			third = micro/patch #
				-> bug fixes only, no new features
				-> changes much be FWD and BKWD compatible

		Even/odd strategy
			-> some prjs minor number comp to indicate the stability
			-> even = stable, odd = unstable
			-> offers way to release new functionality for testing w/o prod having unstable code


book chapter 2: Getting Started
------------------------------------------------

twofold task
	-> acquire users
	-> acquire developers

user and developer refer to someone's relationship to the project, not identity in the world
	-> a dev could used a project (library), which would make them a user
		-> if they contribut back upstream, can also be a dev of the prj


Always look to see if there is an existing prj that does what you want, b4 starting your own


Necessary to invest enough into presentation so that newcomers can get past the initial obstacle of unfamiliarity
	-> again, keep the hactivation energy low

Front page must make it unambiguously clear that the project is free or open source
	-> could lose contribs if you don't
	-> list the exact license



Dev Status
	-> ppl want to know the diff b/w current reality and prjs promise
	-> should always reflect reality
		-> don't be afraid of looking unready
		-> don't inflate or hype status


Downloads
	-> dldable as source code in standard formats
		-> binary (exe) packages not necessary when first getting started (unless getting to run would be a lot of work for people)
	-> distro mechanism should be convenient, std, and low overhead as possible
	-> get this process setup early as you could lose devs due to a long/complicated setup



Dev Guidelines
	-> social more than technical
	-> explain how to interact w/ each other and w/ users

		-> ptrs to forums
		-> how to report bugs/submit patches
		-> some indication of how dev is usually done and how decisions are made


Documentation
	-> tell reader how much technical expertise they're expected to have
	-> describe clearly how to setup software (w/ diag test to confirm)
	-> give 1 tutorial style example of how to do a common task
	-> label the areas whr the doc is known to be incomplete

	-> should be on website and in the distro


Choose license and apply it
	GPL - if you don't want your code in proprietary programs
	AGPL - consider this if users interact w/ code primarily over network connection
			-> extra clause to establish network accessibility as a form of distro


Apply license to software
	-> state the license clearly on the prjs front page
	-> SW itself should include this
		-> put the full ilcense text in a file called COPYING (or LICENSE) include w/ source code
			-> then short notice in a comment at the top of each source file, naming the c-right date, holder, license, and saying where to find the full text of license


Code of Conduct
	-> good to have (or at least a trend)



Practice code review
	-> look at changes as they arrive aka commit review
	-> should even be public


Be open from day one
	-> put it out in the open on the first day
		-> the longer it is closed, the harder it is to open source it later
			-> if you do this, you run the risk of doing things like:
				checking passwords or customer specific items into VCS
				sample data from live (and confid) info
				bug reporsts containing sensitive data
				comments that are inflamitory to a client
				etc..




book chapter 7: Packaging, Releasing, and Daily Development
----------------------------------------------------------------

See notes on release versioning from the lecture


Release Branches
	-> free SW prj in continuous state of release

	-> a branch in VCS which the code is destined for this release can be isolated from the mainline development

	-> maintenance can continue in parallel if you version the branches
		-> can be a branch from another branch
			i.e. dev is a branch of main, a single fix or something is a branch of dev
			could have multiple dev versions with multiple branches as well


Stabilization is the process of getting a release branch into a releasable stated
	-> deciding which changes will or won't be in the release, shaping the branch content accordingly


Time-Based releases - prj puts out a new release at an absolutely regular rythm, such as every 6 months

Feature-Based releases - released when certain features are complete


Dictatorship by release owner
	-> group agrees to let 1 person be the release owner


voting on changes
	-> opposite of dictatorship, devs can vote on which changes to include in the release
	



















